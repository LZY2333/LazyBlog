---
title: Webpack VS Vite Vs Rspack
date: 2025-04-23 15:29:03
hide: true
tags:
    - webpack
---


## Webpack
【Bundle】【Loader】【Plugin】【AST】

### 核心技术支撑 / 升级点

- **Bundle 模型**：一切资源最终合并为依赖图  
- **Loader**：一切文件皆模块的转换机制  
- **Plugin**：高度可扩展的生命周期钩子体系  
- **AST 分析**：基于 AST 的静态依赖分析  

### 速度慢的原因

- **全量打包**：启动即构建完整依赖图  
- **单线程瓶颈**：核心流程长期运行在 Node.js 单线程  
- **插件链过长**：大量 Loader / Plugin 串行执行  
- **历史包袱重**：为兼容复杂场景牺牲了性能  

## Vite
【原生 ESM】【按需编译】【Rollup】【HMR】

### 核心技术支撑 / 升级点

- **原生 ESM**：开发环境直接使用浏览器 ES Module 能力  
- **按需编译**：只编译当前页面实际依赖的模块  
- **Rollup**：生产构建阶段使用 Rollup 进行打包  
- **HMR**：基于模块级更新的热替换机制  

### 速度快的原因

- **跳过打包**：开发阶段不做 bundle，启动时间极短  
- **精确更新**：HMR 只更新单个模块而非整棵依赖树  
- **缓存友好**：依赖预构建后长期复用  
- **开发与生产解耦**：开发快、生产稳，各司其职  

## Rspack
【Rust】【SWC】【并行编译】【兼容 Webpack 生态】

### 核心技术支撑 / 升级点

- **Rust**：使用 Rust 重写核心编译流程，获得接近原生的执行性能  
- **SWC**：替代 Babel / Terser 的 JS / TS 转译与压缩工具  
- **并行编译**：多线程 + 任务调度最大化利用 CPU  
- **Webpack 兼容**：Loader / Plugin API 与 Webpack 高度一致，迁移成本低  

### 速度快的原因

- **系统级语言**：Rust 相比 JS 在大量 AST 与 IO 操作中性能优势明显  
- **编译阶段合并**：转译、压缩、构建链路更短，减少中间产物  
- **多核利用**：天生支持高并发任务调度  
- **减少 JS 运行时开销**：避免 Node.js 单线程瓶颈  

---

## 总结对比

| 工具     | 核心优势           | 适合场景 |
|----------|------------------|----------|
| Rspack  | 极致构建性能       | 大型项目 / CI 构建 / Webpack 用户 |
| Vite    | 开发体验极佳       | 中小项目 / 组件库 / 业务开发 |
| Webpack | 生态成熟、可控性强 | 超复杂工程 / 定制化构建 |

---

## 一句话结论

- **Webpack**：功能最强但最重，解决的是“一切复杂工程问题”
- **Vite**：用浏览器能力绕过打包，解决的是“启动慢”  
- **Rspack**：用 Rust 重构 Webpack，解决的是“构建慢”  
