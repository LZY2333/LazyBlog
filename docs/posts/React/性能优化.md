---
title: 性能优化
date: 2024-04-29 19:33:27
categories: 经验帖
hide: true
tags:
    - JS基础
    - react
---

[一份完整的「前端性能优化」手册](https://juejin.cn/post/7429128606749949978#heading-13)

## 性能衡量指标
我们是三个指标

LCP(Largest Contentful Paint) 子应用要求是1.5秒

INP(Interaction to Next Paint) 事件触发到页面可交互

react组件重新渲染次数

## Performance调试

Performance 录制 刷新页面 等待渲染完成，停止

看哪一块CPU占用高 再其中找callTree里哪个函数耗时长

模拟低配电脑: network 改成slow 4G

## LCP处理----------------------------------------

## 1.资源控制
【资源体积控制】  
Tree Shaking  
图片必须小于50KB WebP  
精简字体包  
精简三方库

【拆包】  
路由级拆包150KB  
组件级懒加载

处理方式:  
路由分包`React.lazy` + `Suspense`  
配置husky进行检查

## 2.网络层
强缓存(30天2592000) + 协商缓存  
CDN  
gzip: CDN gzip + brotli，源站可以不开

## 3.延迟低优先级任务
`requestIdleCallback` 及降级 `setTimeout`  
项目首屏请求非常多，远远超过6个的并发上限  
【合并请求】我们会要求后端合并一些请求  
【低优先级】消息提醒 第三方性能监控SDK

> requestAnimationFrame 下一帧前执行,用于动画,所以不适合

## 4.团队规范
禁止组件内style, 使用CSSModule文件 + CSS token

## 5.React性能优化
本质: 减少不必要的渲染  
即: 自身state变化, 父组件rerender, context变化

### React.memo

1. React.memo 包裹复杂组件
2. 组件Props中的 useMemo(对象) useCallback(函数)

> memo 对新旧props进行浅比较  
> memo必须和useMemo/useCallback一起使用,内部创建的 function/object 每次都是新的  
> 只要父组件rerender就会引发子组件rerender，除非子组件用了memo

### 复杂组件分离封装
避免其他属性的变更导致复杂组件也重新渲染

### serState尽量合并(react17)
react17中，异步请求返回的多组数据，统一调用 unstable_batchedUpdates，react18自动批处理

### ref储存非响应式数据

### context跨组件传递数据
不通过props进行层层传递，以保证精准更新到真正用到该值的组件

另一方面请注意，context值改变时，所有消费了该context的组件都会rerender  
使用社区提供的use-context-selector能暂时解决这个问题  
使用react18 的 useSyncExternalStore 或者 zustand 可以 完美解决这个问题  
[如何优雅的使用 React Context](https://juejin.cn/post/7244838033454727227?searchId=20241121213404D44B54DD9E655C3284AE)

### 状态单一职责，拆分更小粒度，不要一个大对象放各种值

### display:none 代替 if

### 升级React18

### 设置唯一Key且不能为索引
这样设置就相当于是从前往后一一比对，key相同，就会进入内容的对比

### 封装请求层面的缓存 (key为请求参数 过期时间 实时获取标记)

### 三重架构

## webpack优化配置
TerserWebpackPlugin JS压缩  
CssMinimizerPlugin CSS压缩

url-loader(options.limit)  
type:'asset' maxSize(8K 默认转64base)

HtmlWebpackTagsPlugin external + CDN注入
