---
title: Monorepo
date: 2026-01-26 12:20:14
categories: 技术栈
tags: 
    - 微前端
    - Monorepo
hide: true
---

## Single-repo阶段

当一个应用足够大时，必然面临 性能 维护 协作成本问题

__【性能】__ 代码体量巨大，构建时间长

__【维护】__ 模块高度耦合导致 修改/技术栈演进 风险大

__【协作】__ 团队大 并行开发 协作和管理成本高

__我们需要解耦更清晰的 代码边界 团队边界, 达到降低 协作/构建/维护成本__

解耦的第一步就是 源代码拆分，多Git仓库模式 自然诞生

## Multirepo阶段

每一个项目/模块/服务 一个独立 Git 仓库

有了清晰的 代码边界 团队边界, 但降低了 协同效率

__【依赖】__ 重复安装，版本统一控制，规范统一控制

__【协作】__ 涉及多仓库的需求，需多次提交发布

__【初始化】__ 新人clone/install多个仓库，配置不同环境

## Monorepo阶段

多个项目 / 包 / 应用，放在同一个 Git 仓库中统一管理

### 核心优势

#### 1. 跨项目复用能力强

- 公共工具函数
- 设计系统 / 组件库
- hooks / utils / configs

**和“自己写一个 npm 私有组件库”的区别？**

- npm 组件库：
  - 发布 → 安装 → 升级
  - 存在版本滞后
- Monorepo：
  - **源码级直接依赖**
  - 修改即生效，无发布成本
  - 更适合高频协作的内部项目

#### 2. 依赖统一管理

- 所有项目共享依赖版本
- 避免「幽灵 bug」（版本不一致导致）
- 降低 node_modules 体积

#### 3. 原子化提交（Atomic Commit）

- 一个需求涉及多个包：
  - UI 改动
  - 工具函数改动
  - 文档改动  
👉 **一次提交完成**

#### 4. 工程规范高度一致

- 统一：
  - lint / format
  - commit 规范
  - CI / CD 流程
- 工程体验更稳定

#### 5. 更适合微前端 / 多应用场景

- 主应用 + 子应用
- 多业务线共用基础设施
- BFF / SDK / 前端应用共仓管理

---

## Monorepo 的常见挑战

- 仓库体积变大
- 权限控制相对粗
- 不合理的构建会导致：
  - **全量 install**
  - **全量 build**
- 对工具链要求更高

👉 所以 **Monorepo = 工程能力换效率**

---

## pnpm 实践 Monorepo 怎么做？

### 1. 基础目录结构示例

```txt
repo-root
├── apps
│   ├── web
│   └── admin
├── packages
│   ├── ui
│   ├── utils
│   └── eslint-config
├── pnpm-workspace.yaml
├── package.json
└── tsconfig.base.json
